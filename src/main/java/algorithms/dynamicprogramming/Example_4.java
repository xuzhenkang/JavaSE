package algorithms.dynamicprogramming;

/**
 * 题目：给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，
 * 路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。
 * 如果给定的m如大家看到的样子，路径1,3,1,0,6,1,0是所有路径中路径和最小的，
 * 所以返回12.
 * 1 3 5 9
 * 8 1 3 4
 * 5 0 6 1
 * 8 8 4 0
 * 
 * 分析：
 * 假设矩阵m的大小为M*N，行数为M，列数为N，生成大小和m一样的矩阵dp，行数为M,
 * 列数为N。dp[i][j]的值表示从左上角，也就是(0,0)位置，走到(i,j)位置的
 * 最小路径和。
 * 
 *         m                    dp
 * ┌───┬───┬───┬───┐    ┌───┬───┬───┬───┐
 * │ 1 │ 3 │ 5 │ 9 │    │ 1 │ 4 │ 9 │18 │
 * ├───┼───┼───┼───┤    ├───┼───┼───┼───┤
 * │ 8 │ 1 │ 3 │ 4 │    │ 9 │ 5 │ 8 │12 │
 * ├───┼───┼───┼───┤    ├───┼───┼───┼───┤
 * │ 5 │ 0 │ 6 │ 1 │    │14 │ 5 │11 │12 │
 * ├───┼───┼───┼───┤    ├───┼───┼───┼───┤
 * │ 8 │ 8 │ 4 │ 0 │    │22 │13 │15 │12 │
 * └───┴───┴───┴───┘    └───┴───┴───┴───┘
 *                      ┌dp[i-1][j]┐
 * dp[i][j] = m[i][j] + ┤          ├ 两者中取最小的
 *                      └dp[i][j-1]┘
 * @author Dan
 *
 */
public class Example_4 {
	public static int s1(int[][] m) {
		
		int[][] dp = new int[m.length][m[0].length];
		
		dp[0][0] = m[0][0];
		for (int i = 1; i < dp[0].length; i++) {
			dp[0][i] = m[0][i] + dp[0][i-1];
		}
		for (int i = 1; i < dp.length; i++) {
			dp[i][0] = m[i][0] + dp[i-1][0];
		}
		for (int i = 1; i < dp.length; i++) {
			for (int j = 1; j < dp[i].length; j++) {
				dp[i][j] = m[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
			}
		}
		return dp[dp.length-1][dp.length-1];
	}
	public static void main(String[] args) {
		int[][] m = { 
				{ 1, 3, 5, 9 }, 
				{ 8, 1, 3, 4 }, 
				{ 5, 0, 6, 1 }, 
				{ 8, 8, 4, 0 } };
		System.out.println(s1(m));
	}
	
}
